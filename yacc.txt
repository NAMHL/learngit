%{
   #include <stdio.h>
   #include <stdarg.h>
   #include "need.h"
   nodeType *opr(int oper,int nops,...);
   nodeType *id(int i);
   nodeType *con(int value);
   void freeNode(nodeType *p);
   int ex(nodeType *p);
   int yylex(void);
   void yyerror(char*s);
   void addVar(char *);
   int totalVar=0;
   int currentVar;
   Map sym[100];
%}
%union
{
   int iValue;
   char sIndex;
   nodeType *nPtr;
 };
%token<iValue>INTEGER
%token<sIndex>VARIABLE
%token FOR WHILE PRINT _BEGIN END DELAY ROBOT BODY BODY1 BODY2 HEAD HEAD1 HEAD2
LUA LLA RUA RLA LUL LLL RUL RLL
%nonassoc IF
%nonassoc ELSE
%left AND OR
%left GE LE EQ NE '>''<'
%left '+''-'
%left '*''/'
%left SELFADD SELFMINUS PRESELFADD PRESELFMINUS
%nonassoc UMINUS
%type <nPtr> stmt expr stmt_list expr_set expr_setself expr_comp
%%
program:
     _BEGIN function END  {exit(0);}
     ;
function:
     function stmt  {ex($2);freeNode($2);}
     |
      ;
stmt:
     ';'                {$$=opr(';',2,NULL,NULL);}
     |expr';'           {$$=$1;}
     |expr_set';'       {$$=$1;}
	 |PRINT expr';'     {$$=opr(PRINT,1,$2);}
     |PRINT expr_set';'  {$$=opr(PRINT,1,$2);}
     |WHILE'('expr_comp')'stmt {$$=opr(WHILE,2,$3,$5);}
     |FOR'('expr_set';'expr_comp';'expr_set')' stmt {$$=opr(FOR,4,$3,$5,$7,$9);}
	 |IF'('expr_comp')'stmt ELSE stmt %prec ELSE{$$=opr(IF,3,$3,$5,$7);}
     |IF'('expr_comp')'stmt %prec IF {$$=opr(IF,2,$3,$5);}
	 |'{'stmt_list'}' {$$=$2;}
	 |ROBOT'{'expr'}'';'  {$$=opr(ROBOT,1,$3);}
	 |DELAY'{'expr'}'';'  {$$=opr(DELAY,1,$3);}
	 |'{'BODY'}''{'expr'}'';' {$$=opr(BODY,1,$5);}
	 |BODY1'{'expr'}'';' {$$=opr(BODY1,1,$3);}
	 |BODY2'{'expr'}'';' {$$=opr(BODY2,1,$3);}
	 |'{'HEAD'}''{'expr'}'';' {$$=opr(HEAD,1,$5);}
	 |HEAD1'{'expr'}'';' {$$=opr(HEAD1,1,$3);}
     |HEAD2'{'expr'}'';' {$$=opr(HEAD2,1,$3);}
     |LUA'{'expr'}'';' {$$=opr(LUA,1,$3);}
     |LLA'{'expr'}'';' {$$=opr(LLA,1,$3);}
     |RUA'{'expr'}'';' {$$=opr(RUA,1,$3);}
     |RLA'{'expr'}'';' {$$=opr(RLA,1,$3);}
     |LUL'{'expr'}'';' {$$=opr(LUL,1,$3);}
     |LLL'{'expr'}'';' {$$=opr(LLL,1,$3);}
     |RUL'{'expr'}'';' {$$=opr(RUL,1,$3);}
     |RLL'{'expr'}'';' {$$=opr(RLL,1,$3);}
     ;
stmt_list:
      stmt {$$=$1;}
      |stmt_list stmt {$$=opr(';',2,$1,$2);}
	  ;
expr_set:
      VARIABLE'='expr {$$=opr('=',2,id($1),$3);}
	  |VARIABLE'='expr_setself{$$=opr('=',2,id($1),$3);}
	  |expr_setself
	  ;
expr_setself:
      SELFADD VARIABLE  {$$=opr(PRESELFADD,1,id($2));}
	  |SELFMINUS VARIABLE {$$=opr(PRESELFMINUS,1,id($2));}
	  |VARIABLE SELFADD {$$=opr(SELFADD,1,id($1));}
	  |VARIABLE SELFMINUS {$$=opr(SELFMINUS,1,id($1));}
	  |'('expr_setself')' {$$=$2;}
	  ;
expr_comp:
      expr'<'expr {$$=opr('<',2,$1,$3);}
      |expr'>'expr {$$=opr('>',2,$1,$3);}
      |expr GE expr {$$=opr(GE,2,$1,$3);}
      |expr LE expr {$$=opr(LE,2,$1,$3);}
      |expr NE expr {$$=opr(NE,2,$1,$3);}
      |expr EQ expr {$$=opr(EQ,2,$1,$3);}
      |expr_comp AND expr_comp {$$=opr(AND,2,$1,$3);}
	  |expr_comp OR expr_comp {$$=opr(OR,2,$1,$3);}
	  |'('expr_comp')'  {$$=$2;}
expr:
      INTEGER     {$$=con($1);}
      |VARIABLE    {$$=id($1);}
      |'-'expr %prec UMINUS  {$$=opr(UMINUS,1,$2);}
      |expr'+'expr {$$=opr('+',2,$1,$3);}
      |expr'-'expr {$$=opr('-',2,$1,$3);}
      |expr'*'expr {$$=opr('*',2,$1,$3);}
      |expr'/'expr {$$=opr('/',2,$1,$3);}
      |'('expr')'{$$=$2;}
      ;
%%
nodeType*con(int value)
{
    nodeType*p;
    p=malloc(sizeof(nodeType));
    p->type=typeCon;
    p->con.value=value;
    return p;
}
nodeType *id(int i)
{
   nodeType*p;
   p=malloc(sizeof(nodeType));
   p->type=typeId;
   p->id.i=i;
   return p;
}

nodeType *opr(int oper,int nops,...)
{
   va_list ap;
   nodeType *p;
   int i;
   p=malloc(nops*sizeof(nodeType));
   p->type=typeOpr;
   p->opr.oper=oper;
   p->opr.nops=nops;
   va_start(ap,nops);
   for(i=0;i<nops;i++)
      p->opr.op[i]=va_arg(ap,nodeType*);
   va_end(ap);
   return p;
}
void addVar(char *s)
{
 if(totalVar==0)
 {
    strcpy(sym[0].s,s);
    totalVar++;
    currentVar=0;
    return;
 }
 int i;
 for(i=0;i<totalVar;i++)
 {
   if(strcmp(sym[i].s,s)==0)
   {
      currentVar=i;
      return;
   }
}
 strcpy(sym[totalVar].s,s);
 currentVar=totalVar;
 totalVar++;
}

int ex(nodeType*p)
{
   if(!p) return 0;
   switch(p->type)
   {
       case typeCon:return p->con.value;
       case typeId: return sym[p->id.i].n;
       case typeOpr:
           switch(p->opr.oper)
           {
                case WHILE:while(ex(p->opr.op[0])) ex(p->opr.op[1]); return 0;
                case IF: if(ex(p->opr.op[0])) ex(p->opr.op[1]);
                         else if(p->opr.nops>2)  ex(p->opr.op[2]);
                         return 0;
                case FOR:ex(p->opr.op[0]);
				         while(ex(p->opr.op[1]))
				         {
						    ex(p->opr.op[3]);
							ex(p->opr.op[2]);
						 }
				         return 0;
				case PRINT:printf("%d\n",ex(p->opr.op[0]));return 0;
				case DELAY:printf("delay{%d}\n",ex(p->opr.op[0]));return 0;
				case ROBOT:printf("robot{%d}\n",ex(p->opr.op[0]));return 0;
				case BODY: printf("body%d\n",ex(p->opr.op[0]));return 0;
				case BODY1: printf("body+%d\n",ex(p->opr.op[0]));return 0;
				case BODY2: printf("body-%d\n",ex(p->opr.op[0]));return 0;
				case HEAD: printf("head%d\n",ex(p->opr.op[0]));return 0;
				case HEAD1:printf("head+%d\n",ex(p->opr.op[0]));return 0;
				case HEAD2:printf("head-%d\n",ex(p->opr.op[0]));return 0;
				case LUA:printf("lua%d\n",ex(p->opr.op[0]));return 0;
                case LLA:printf("lla%d\n",ex(p->opr.op[0]));return 0;
                case RUA:printf("rua%d\n",ex(p->opr.op[0]));return 0;
				case RLA:printf("rla%d\n",ex(p->opr.op[0]));return 0;
				case LUL:printf("lul%d\n",ex(p->opr.op[0]));return 0;
				case LLL:printf("lll%d\n",ex(p->opr.op[0]));return 0;
				case RUL:printf("rul%d\n",ex(p->opr.op[0]));return 0;
				case RLL:printf("rll%d\n",ex(p->opr.op[0]));return 0;
				case';':ex(p->opr.op[0]);  return ex(p->opr.op[1]);
                case'=':return sym[p->opr.op[0]->id.i].n=ex(p->opr.op[1]);
                case UMINUS:return -ex(p->opr.op[0]);
                case '+': return ex(p->opr.op[0])+ex(p->opr.op[1]);
                case '-':return ex(p->opr.op[0])-ex(p->opr.op[1]);
                case '*': return ex(p->opr.op[0])*ex(p->opr.op[1]);
                case '/': return ex(p->opr.op[0])/ex(p->opr.op[1]);
                case '<': return ex(p->opr.op[0])<ex(p->opr.op[1]);
                case '>': return ex(p->opr.op[0])>ex(p->opr.op[1]);
                case GE: return ex(p->opr.op[0])>=ex(p->opr.op[1]);
                case LE: return ex(p->opr.op[0])<=ex(p->opr.op[1]);
                case NE: return ex(p->opr.op[0])!=ex(p->opr.op[1]);
                case EQ: return ex(p->opr.op[0])==ex(p->opr.op[1]);
                case PRESELFADD:return ++sym[p->opr.op[0]->id.i].n;
				case PRESELFMINUS:return --sym[p->opr.op[0]->id.i].n;
				case SELFADD:return sym[p->opr.op[0]->id.i].n++;
				case SELFMINUS:return sym[p->opr.op[0]->id.i].n--;
				case AND:return ex(p->opr.op[0])&&ex(p->opr.op[1]);
				case OR:return ex(p->opr.op[0])||ex(p->opr.op[1]);
			 }
    }
    return 0;
}
void freeNode(nodeType *p)
{
    int i;
    if(!p) return ;
    if(p->type==typeOpr)
    {
        for(i=0;i<p->opr.nops;i++)
         freeNode(p->opr.op[i]);
     }
     free(p);
}
void yyerror(char *s)
{
   fprintf(stdout,"%s\n",s);
}
#include "lex.yy.c"
int main(void)
{
    yyparse();
    return 0;
}
